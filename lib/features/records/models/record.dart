enum RecordType { live, movie, book, other }

class Record {
  final String id;
  final RecordType type;
  final String title;
  final String artistOrAuthor;
  final DateTime date;
  final String ticketImageUrl;
  final String? ticketSource; // e+, LawTicket, etc.
  final String? setlist;
  final String? mcMemo;
  final String? impressions;

  const Record({
    required this.id,
    required this.type,
    required this.title,
    required this.artistOrAuthor,
    required this.date,
    required this.ticketImageUrl,
    this.ticketSource,
    this.setlist,
    this.mcMemo,
    this.impressions,
  });

  String get typeLabel {
    switch (type) {
      case RecordType.live:
        return 'ライブ';
      case RecordType.movie:
        return '映画';
      case RecordType.book:
        return '本';
      case RecordType.other:
        return 'その他';
    }
  }

  factory Record.fromJson(Map<String, dynamic> json) {
    return Record(
      id: json['id'] as String,
      type: RecordType.values.firstWhere(
        (e) => e.name == json['type'],
        orElse: () => RecordType.other,
      ),
      title: json['title'] as String,
      artistOrAuthor: json['artist_or_author'] as String,
      date: DateTime.parse(json['date'] as String),
      ticketImageUrl: json['ticket_image_url'] as String? ?? '',
      ticketSource: json['ticket_source'] as String?,
      setlist: json['setlist'] as String?,
      mcMemo: json['mc_memo'] as String?,
      impressions: json['impressions'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      // id is usually generated by DB on insert, but included if updating
      // 'id': id,
      'type': type.name,
      'title': title,
      'artist_or_author': artistOrAuthor,
      'date': date.toIso8601String(),
      'ticket_image_url': ticketImageUrl,
      'ticket_source': ticketSource,
      'setlist': setlist,
      'mc_memo': mcMemo,
      'impressions': impressions,
    };
  }
}
